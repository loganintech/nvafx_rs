/* automatically generated by rust-bindgen */

pub const NVAFX_TRUE: u32 = 1;
pub const NVAFX_FALSE: u32 = 0;
pub const NVAFX_EFFECT_DENOISER: &'static [u8; 9usize] = b"denoiser\0";
pub const NVAFX_EFFECT_DEREVERB: &'static [u8; 9usize] = b"dereverb\0";
pub const NVAFX_EFFECT_DEREVERB_DENOISER: &'static [u8; 18usize] = b"dereverb_denoiser\0";
pub const NVAFX_PARAM_ACTIVE_STREAMS: &'static [u8; 15usize] = b"active_streams\0";
pub const NVAFX_PARAM_INTENSITY_RATIO: &'static [u8; 16usize] = b"intensity_ratio\0";
pub const NVAFX_PARAM_MODEL_PATH: &'static [u8; 11usize] = b"model_path\0";
pub const NVAFX_PARAM_NUM_CHANNELS: &'static [u8; 13usize] = b"num_channels\0";
pub const NVAFX_PARAM_NUM_SAMPLES_PER_FRAME: &'static [u8; 22usize] = b"num_samples_per_frame\0";
pub const NVAFX_PARAM_NUM_STREAMS: &'static [u8; 12usize] = b"num_streams\0";
pub const NVAFX_PARAM_SAMPLE_RATE: &'static [u8; 12usize] = b"sample_rate\0";
pub const NVAFX_PARAM_SUPPORTED_NUM_SAMPLES_PER_FRAME: &'static [u8; 32usize] =
    b"supported_num_samples_per_frame\0";
pub const NVAFX_PARAM_USE_DEFAULT_GPU: &'static [u8; 16usize] = b"use_default_gpu\0";
pub const NVAFX_PARAM_DENOISER_MODEL_PATH: &'static [u8; 11usize] = b"model_path\0";
pub const NVAFX_PARAM_DENOISER_SAMPLE_RATE: &'static [u8; 12usize] = b"sample_rate\0";
pub const NVAFX_PARAM_DENOISER_NUM_SAMPLES_PER_FRAME: &'static [u8; 22usize] =
    b"num_samples_per_frame\0";
pub const NVAFX_PARAM_DENOISER_NUM_CHANNELS: &'static [u8; 13usize] = b"num_channels\0";
pub const NVAFX_PARAM_DENOISER_INTENSITY_RATIO: &'static [u8; 16usize] = b"intensity_ratio\0";
pub const NVAFX_PARAM_DENOISER_SUPPORTED_NUM_SAMPLES_PER_FRAME: &'static [u8; 32usize] =
    b"supported_num_samples_per_frame\0";
#[doc = " Success"]
pub const NvAFX_Status_NVAFX_STATUS_SUCCESS: NvAFX_Status = 0;
#[doc = " Failure"]
pub const NvAFX_Status_NVAFX_STATUS_FAILED: NvAFX_Status = 1;
#[doc = " Handle invalid"]
pub const NvAFX_Status_NVAFX_STATUS_INVALID_HANDLE: NvAFX_Status = 2;
#[doc = " Parameter value invalid"]
pub const NvAFX_Status_NVAFX_STATUS_INVALID_PARAM: NvAFX_Status = 3;
#[doc = " Parameter value immutable"]
pub const NvAFX_Status_NVAFX_STATUS_IMMUTABLE_PARAM: NvAFX_Status = 4;
#[doc = " Insufficient data to process"]
pub const NvAFX_Status_NVAFX_STATUS_INSUFFICIENT_DATA: NvAFX_Status = 5;
#[doc = " Effect not supported"]
pub const NvAFX_Status_NVAFX_STATUS_EFFECT_NOT_AVAILABLE: NvAFX_Status = 6;
#[doc = " Given buffer length too small to hold requested data"]
pub const NvAFX_Status_NVAFX_STATUS_OUTPUT_BUFFER_TOO_SMALL: NvAFX_Status = 7;
#[doc = " Model file could not be loaded"]
pub const NvAFX_Status_NVAFX_STATUS_MODEL_LOAD_FAILED: NvAFX_Status = 8;
#[doc = " Model is not loaded, it needs to be loaded for this operation"]
pub const NvAFX_Status_NVAFX_STATUS_MODEL_NOT_LOADED: NvAFX_Status = 9;
#[doc = " Selected model is incompatible"]
pub const NvAFX_Status_NVAFX_STATUS_INCOMPATIBLE_MODEL: NvAFX_Status = 10;
#[doc = " The selected GPU is not supported. The SDK requires Turing and above GPU with Tensor cores"]
pub const NvAFX_Status_NVAFX_STATUS_GPU_UNSUPPORTED: NvAFX_Status = 11;
#[doc = " No supported GPU found on the system"]
pub const NvAFX_Status_NVAFX_STATUS_NO_SUPPORTED_GPU_FOUND: NvAFX_Status = 12;
#[doc = " Current GPU is not the one selected"]
pub const NvAFX_Status_NVAFX_STATUS_WRONG_GPU: NvAFX_Status = 13;
#[doc = " Cuda operation failure"]
pub const NvAFX_Status_NVAFX_STATUS_CUDA_ERROR: NvAFX_Status = 14;
#[doc = " Invalid operation performed"]
pub const NvAFX_Status_NVAFX_STATUS_INVALID_OPERATION: NvAFX_Status = 15;
#[doc = " API return values"]
pub type NvAFX_Status = u32;
pub type NvAFX_Bool = ::std::os::raw::c_char;
pub const LoggingSeverity_t_LOG_LEVEL_ERROR: LoggingSeverity_t = 0;
pub const LoggingSeverity_t_LOG_LEVEL_WARNING: LoggingSeverity_t = 1;
pub const LoggingSeverity_t_LOG_LEVEL_INFO: LoggingSeverity_t = 2;
#[doc = " Logging level to enable, each level is inclusive of the level preceding it"]
pub type LoggingSeverity_t = u32;
#[doc = " Logging level to enable, each level is inclusive of the level preceding it"]
pub use self::LoggingSeverity_t as LoggingSeverity;
pub const LoggingTarget_t_LOG_TARGET_NONE: LoggingTarget_t = 0;
pub const LoggingTarget_t_LOG_TARGET_STDERR: LoggingTarget_t = 1;
pub const LoggingTarget_t_LOG_TARGET_FILE: LoggingTarget_t = 2;
pub const LoggingTarget_t_LOG_TARGET_CALLBACK: LoggingTarget_t = 4;
pub type LoggingTarget_t = u32;
pub use self::LoggingTarget_t as LoggingTarget;
#[doc = " Function used for logging callback"]
pub type logging_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        level: LoggingSeverity,
        log: *const ::std::os::raw::c_char,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " We use strings as effect selectors"]
pub type NvAFX_EffectSelector = *const ::std::os::raw::c_char;
#[doc = " We use strings as parameter selectors."]
pub type NvAFX_ParameterSelector = *const ::std::os::raw::c_char;
#[doc = " Each effect instantiation is associated with an opaque handle."]
pub type NvAFX_Handle = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " @brief Get a list of audio effects supported"]
    #[doc = ""]
    #[doc = " @param[out] num_effects Number of effects returned in effects array"]
    #[doc = " @param[out] effects A list of effects returned by the API. This list is"]
    #[doc = "                     statically allocated by the API implementation. Caller"]
    #[doc = "                     does not need to allocate."]
    #[doc = ""]
    #[doc = " @return Status values as enumerated in @ref NvAFX_Status"]
    pub fn NvAFX_GetEffectList(
        num_effects: *mut ::std::os::raw::c_int,
        effects: *mut *mut NvAFX_EffectSelector,
    ) -> NvAFX_Status;
}
extern "C" {
    #[doc = " @brief Create a new instance of an audio effect."]
    #[doc = ""]
    #[doc = " @param[in] code   The selector code for the desired audio Effect."]
    #[doc = " @param[out] effect   A handle to the Audio Effect instantiation."]
    #[doc = ""]
    #[doc = " @return Status values as enumerated in @ref NvAFX_Status"]
    pub fn NvAFX_CreateEffect(
        code: NvAFX_EffectSelector,
        effect: *mut NvAFX_Handle,
    ) -> NvAFX_Status;
}
extern "C" {
    #[doc = " @brief Delete a previously instantiated audio Effect."]
    #[doc = ""]
    #[doc = " @param[in]  effect A handle to the audio Effect to be deleted."]
    #[doc = ""]
    #[doc = " @return Status values as enumerated in @ref NvAFX_Status"]
    pub fn NvAFX_DestroyEffect(effect: NvAFX_Handle) -> NvAFX_Status;
}
extern "C" {
    #[doc = " Set the value of the selected parameter (unsigned int, char*, float)"]
    #[doc = ""]
    #[doc = " @param[in]  effect      The effect to configure."]
    #[doc = " @param[in]  param_name  The selector of the effect parameter to configure."]
    #[doc = " @param[in]  val         The value to be assigned to the selected effect parameter."]
    #[doc = " @param[in]  list[]      The list with values to be assigned to the selected effect parameter."]
    #[doc = " @param[in]  list_size   Number of elements of the list[]"]
    #[doc = ""]
    #[doc = " @return Status values as enumerated in @ref NvAFX_Status"]
    pub fn NvAFX_SetU32(
        effect: NvAFX_Handle,
        param_name: NvAFX_ParameterSelector,
        val: ::std::os::raw::c_uint,
    ) -> NvAFX_Status;
}
extern "C" {
    pub fn NvAFX_SetString(
        effect: NvAFX_Handle,
        param_name: NvAFX_ParameterSelector,
        val: *const ::std::os::raw::c_char,
    ) -> NvAFX_Status;
}
extern "C" {
    pub fn NvAFX_SetFloat(
        effect: NvAFX_Handle,
        param_name: NvAFX_ParameterSelector,
        val: f32,
    ) -> NvAFX_Status;
}
extern "C" {
    pub fn NvAFX_SetBoolList(
        effect: NvAFX_Handle,
        param_name: NvAFX_ParameterSelector,
        list: *const NvAFX_Bool,
        list_size: ::std::os::raw::c_uint,
    ) -> NvAFX_Status;
}
extern "C" {
    #[doc = " Get the value of the selected parameter (unsigned int, char*, float)"]
    #[doc = ""]
    #[doc = " @param[in]  effect       The effect handle."]
    #[doc = " @param[in]  param_name   The selector of the effect parameter to read."]
    #[doc = " @param[out] val          Buffer in which the parameter value will be assigned."]
    #[doc = " @param[in]  max_length  The length in bytes of the buffer provided."]
    #[doc = " @param[out] list[]      The list with values to be retrieved for the selected effect parameter."]
    #[doc = " @param[out] list_size   Number of elements of list[]"]
    #[doc = ""]
    #[doc = " @return Status values as enumerated in @ref NvAFX_Status"]
    pub fn NvAFX_GetU32(
        effect: NvAFX_Handle,
        param_name: NvAFX_ParameterSelector,
        val: *mut ::std::os::raw::c_uint,
    ) -> NvAFX_Status;
}
extern "C" {
    pub fn NvAFX_GetString(
        effect: NvAFX_Handle,
        param_name: NvAFX_ParameterSelector,
        val: *mut ::std::os::raw::c_char,
        max_length: ::std::os::raw::c_int,
    ) -> NvAFX_Status;
}
extern "C" {
    pub fn NvAFX_GetFloat(
        effect: NvAFX_Handle,
        param_name: NvAFX_ParameterSelector,
        val: *mut f32,
    ) -> NvAFX_Status;
}
extern "C" {
    pub fn NvAFX_GetU32List(
        effect: NvAFX_Handle,
        param_name: NvAFX_ParameterSelector,
        list: *mut ::std::os::raw::c_uint,
        list_size: *mut ::std::os::raw::c_uint,
    ) -> NvAFX_Status;
}
extern "C" {
    #[doc = " Load the Effect based on the set params."]
    #[doc = ""]
    #[doc = " @param[in]  effect     The effect object handle."]
    #[doc = ""]
    #[doc = " @return Status values as enumerated in @ref NvAFX_Status"]
    pub fn NvAFX_Load(effect: NvAFX_Handle) -> NvAFX_Status;
}
extern "C" {
    #[doc = " Process the input buffer as per the effect selected. e.g. denoising"]
    #[doc = ""]
    #[doc = " @note The input float data is expected to be standard 32-bit float type with values in range [-1.0, +1.0]"]
    #[doc = ""]
    #[doc = " @param[in]  effect        The effect handle."]
    #[doc = " @param[in]  input         Input float buffer array. It points to an array of buffers where each buffer holds"]
    #[doc = "                           audio data for a single channel. Array size should be same as number of channels"]
    #[doc = "                           expected by the effect. Also ensure sampling rate is same as expected by the Effect."]
    #[doc = "                           For e.g. for denoiser it should be equal to the value returned by NvAFX_GetU32()"]
    #[doc = "                           returned value for NVAFX_FIXED_PARAM_SAMPLE_RATE parameter."]
    #[doc = " @param[out]  output       Output float buffer array. The layout is same as input. It points to an an array of"]
    #[doc = "                           buffers where buffer has audio data corresponding to that channel. The buffers have"]
    #[doc = "                           to be preallocated by caller. Size of each buffer (i.e. channel) is same as that of"]
    #[doc = "                           input."]
    #[doc = " @param[in]  num_samples   The number of samples in the input buffer. After this call returns output will"]
    #[doc = "                           have same number of samples."]
    #[doc = " @param[in]  num_channels  The number of channels in the input buffer. The @a input and @a output should point"]
    #[doc = "                           to @ num_channels number of buffers, one for each channel."]
    #[doc = ""]
    #[doc = " @return Status values as enumerated in @ref NvAFX_Status"]
    pub fn NvAFX_Run(
        effect: NvAFX_Handle,
        input: *mut *const f32,
        output: *mut *mut f32,
        num_samples: ::std::os::raw::c_uint,
        num_channels: ::std::os::raw::c_uint,
    ) -> NvAFX_Status;
}
extern "C" {
    #[doc = " Reset effect state"]
    #[doc = ""]
    #[doc = " @note Allows the state of an effect to be reset. This operation will reset the state of selected in the next"]
    #[doc = "       NvAFX_Run call"]
    #[doc = ""]
    #[doc = " @param[in]  effect        The effect handle."]
    #[doc = " @param[in]  bitmap        Array of NvAFX_Bool parameters which indicates whether a stream is to be reset."]
    #[doc = "                           If the i-th stream is to be reset, the i-th value of the array should be set to NVAFX_TRUE,"]
    #[doc = "                           else it should be set to NVAFX_FALSE."]
    #[doc = " @param[in]  length        The length of the array."]
    #[doc = ""]
    #[doc = " @return Status values as enumerated in @ref NvAFX_Status"]
    pub fn NvAFX_Reset(
        effect: NvAFX_Handle,
        bitmap: *mut NvAFX_Bool,
        length: ::std::os::raw::c_int,
    ) -> NvAFX_Status;
}
extern "C" {
    #[doc = " Initialize Logger"]
    #[doc = ""]
    #[doc = " @note Initializes Logger"]
    #[doc = ""]
    #[doc = " @param[in]  level         The logging level to enable."]
    #[doc = " @param[in]  LoggingTarget Logging targets to write logs to, LoggingTarget_t can be OR'd"]
    #[doc = " @param[in]  filename      The name of the file where to write logs."]
    #[doc = " @param[in]  cb            Callback to use if LOG_TARGET_CALLBACK is enabled."]
    #[doc = " @param[in]  userdata      Data passed back with log callback. Used only when LOG_TARGET_CALLBACK"]
    #[doc = "                           is enabled."]
    #[doc = ""]
    #[doc = " @return Status values as enumerated in @ref NvAFX_Status"]
    pub fn NvAFX_InitializeLogger(
        level: LoggingSeverity,
        target: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        cb: logging_cb_t,
        userdata: *mut ::std::os::raw::c_void,
    ) -> NvAFX_Status;
}
extern "C" {
    #[doc = " Un-initializes Logger"]
    #[doc = ""]
    #[doc = " @note Un-initializes Logger"]
    #[doc = ""]
    #[doc = " @return Status values as enumerated in @ref NvAFX_Status"]
    pub fn NvAFX_UninitializeLogger() -> NvAFX_Status;
}
